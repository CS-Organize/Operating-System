# 운영체제란

![](/img/os-01-01.png)

- 좁은 의미의 운영체제 : 커널(항상 메모리에 상주)
- 넓은 의미의 운영체제 : 커널 + 시스템 유틸리티(메모리에 상주하지 않는 독립적인 프로그램)
  - 예로는 파일 복사하는 별도의 소프트웨어가 있다.

## 커널이란

- 운영체제의 핵심적인 부분으로, 하드웨어와 소프트웨어 사이에서 인터페이스 역할을 하며 시스템 자원의 관리와 제어를 담당
- 어원은 라틴어 "kernēs"에서 유래되었으며 "씨앗"이나 "핵심 생각"을 의미하는 단어로, 나무 열매의 핵심 부분을 가리키는 말

## 운영체제의 목적

1. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
2. 컴퓨터 시스템의 자원을 효율적으로 관리

![](/img/os-01-02.png)

- 하나의 컴퓨터에 동시에 프로그램을 실행해도 본인의 프로그램만 실행하는 것 같은 인상을 줌
  → 컴퓨터 내부적으로 관리를 잘 해서 서로 다른 프로그램들을 동시에 실행 (밑의 그림 오른쪽 아래)
- 사용자는 하드웨어 자원을 어떻게 분배, 관리, 접근하는지 몰라도 운영체제가 있어 편리하게 사용 가능

![](/img/os-01-03.png)

- 자원(resource)
  - 하드웨어 자원 : : CPU, RAM, I/O Device 등
  - 소프트웨어 자원 : 프로세스, 파일, 메세지 등
- 효율만을 생각한다면 특정 프로그램이나 사용자가 차별받는 상황이 생기기 때문에 형평성있는 자원 분배가 필요

## 운영체제의 분류

- 동시 작업 가능 여부
- 사용자의 수
- 처리 방식

![](/img/os-01-04.png)

- 단일 작업 : 예전의 운영체제, 임베디드, 특수적인 목적의 운영체제
- 다중 작업 : 범용적으로 사용되는 현대의 운영체제(unix, windows, ios, android 등)

![](/img/os-01-05.png)

![](/img/os-01-06.png)

![](/img/os-01-07.png)

- time sharing → 현대의 범용적인 운영체제에서 사용
- time sharing의 목적 : 사용자가 느끼기에 빠르게 해주면서 동시에 주어진 자원을 최대한 활용
  → 정확한 시간을 지켜주지는 못하는 사용자 친화적인 처리
- interactive : 사용자의 동작에 따라 바로 반응

![](/img/os-01-08.png)

- Realtime OS → 특수한 목적을 가진 운영체제(정교한 작업)
- pipelining architecture (반도체 공정에서 사용되는 아키텍처)
    <details>
    <summary>자세히</summary>
    컴퓨터 시스템에서 명령어 처리를 효율적으로 수행하기 위한 방법 중 하나입니다. 이 아키텍처는 명령어 처리를 여러 단계로 분할하고, 각 단계를 동시에 수행하여 전체 처리 속도를 향상시킵니다.
    
    파이프라인 아키텍처에서는 명령어 처리 과정을 다수의 단계로 나눕니다. 
    
    일반적으로는 인출(Instruction Fetch), 디코드(Instruction Decode), 실행(Execute), 메모리 접근(Memory Access), 결과 쓰기백(WB, Write Back) 등의 단계로 분할됩니다. 
    
    각 단계는 동일한 시간 동안 처리되며, 여러 명령어가 동시에 진행되는 것처럼 보입니다.
    
    파이프라인 아키텍처의 핵심 개념은 파이프라인 레지스터(Pipeline Register)입니다.
    
    파이프라인 레지스터는 각 단계 사이에 위치하며, 명령어가 한 단계에서 다음 단계로 전달되는데 사용됩니다. 
    
    이를 통해 여러 명령어가 동시에 처리되는 동시성(concurrency)이 실현됩니다.
    
    파이프라인 아키텍처의 장점은 다음과 같습니다:
    
    1. 성능 향상: 파이프라인을 사용하면 여러 명령어가 동시에 실행되므로 전체적인 처리 속도가 향상됩니다.
    2. 자원 활용: 파이프라인은 여러 명령어가 병렬로 처리되기 때문에 처리 단계 간에 자원을 효율적으로 활용할 수 있습니다.
    3. 설계의 단순화: 파이프라인은 처리 단계를 분리하고 각 단계를 독립적으로 설계할 수 있기 때문에 시스템 설계의 단순화를 도모합니다.
    
    그러나 파이프라인 아키텍처에는 몇 가지 주의할 점도 있습니다:
    
    4. 데이터 종속성: 명령어들 사이에 데이터 종속성이 발생할 경우 파이프라인의 효율성이 저하될 수 있습니다. 이를 해결하기 위해 파이프라인 상에서 데이터 종속성을 검출하고 처리하는 추가적인 기법이 필요합니다.
    5. 분기 예측: 분기 명령어가 파이프라인 상에서 처리되는 경우 분기 예측이 필요합니다. 잘못된 분기 예측은 파이프라인을 비워야 하므로 처리 속도에 부정적인 영향을 미칠 수 있습니다.
    6. 하드웨어 복잡성: 파이프라인 아키텍처는 하드웨어적인 복잡성을 가지고 있으며, 설계 및 구현에 대한 추가적인 비용과 복잡도를 요구할 수 있습니다.
    
    파이프라인 아키텍처는 현대 프로세서에서 널리 사용되는 중요한 설계 기법 중 하나입니다.
    이를 통해 명령어 처리의 효율성과 성능을 향상시킬 수 있습니다.
    </details>

- Soft realtime system : 영화, 멀티 미디어 플레이 등 **데드라인은 존재하지만 지키지 못해도 치명적인 결과를 초래하지 않는 시스템에서 사용**
- time sharing 방식을 사용하는 범용 운영체제에서도(특히, 스마트폰) 데드라인을 필요로 하는 작업(네비, 블랙박스 등)이 등장함으로써 어떻게 처리하는 지에 관한 관심이 증가하고 있음

<aside class="note" markdown="1">
💡 우리가 배우는 운영체제
1. 다중 작업(multi tasking)을 지원
2. 다중 사용자(multi user)을 대부분 지원
3. 시분할(time sharing) 방식을 사용
</aside>

## 혼동하기 쉬운 몇 가지 용어들

![](/img/os-01-09.png)

### Multitasking

운영체제에서 여러 개의 작업(Task) 또는 프로세스(Process)를 동시에 실행하는 능력을 의미합니다.\
운영체제는 CPU의 시간을 작업들 사이에서 공유하면서 각 작업이 동시에 실행되는 것처럼 보이게 합니다.\
각 작업은 작은 단위의 시간 슬라이스(time slice)를 할당받아 번갈아가며 실행됩니다.\
Multitasking은 사용자에게는 여러 작업을 동시에 수행하는 것처럼 느껴지게 하며, 시스템 자원을 효율적으로 활용하여 작업의 응답성을 향상시킵니다.

**→ Multitasking은 다수의 작업을 동시에 실행하는 데 중점**

### Multiprogramming

운영체제에서 여러 개의 프로그램이 메모리에 동시에 적재되어 실행되는 것을 의미합니다.\
이는 CPU의 유휴 시간을 최소화하고, 프로그램 실행 시간을 효과적으로 활용하는 데 중점을 둡니다.\
운영체제는 여러 프로그램을 동시에 메모리에 유지하고, CPU가 실행할 수 있는 프로그램을 선택하여 실행합니다.\
이를 통해 프로세스 간에 대기 시간을 최소화하고, 전체 시스템의 처리량과 응답성을 향상시킬 수 있습니다.

**→ Multiprogramming은 동시에 실행되는 프로그램의 개수를 강조**

### Time sharing

멀티유저 시스템에서 여러 사용자가 동시에 컴퓨터 자원을 공유하는 방식을 의미합니다.\
운영체제는 작은 시간 단위로 CPU 시간을 각 사용자에게 번갈아 할당하여 사용자들이 동시에 시스템을 사용하는 것처럼 보이도록 합니다.\
각 사용자는 자신의 작업을 실행하고 결과를 얻을 수 있습니다.\
Time sharing은 사용자들에게 빠른 응답성을 제공하고, 자원의 효율적인 공유를 가능하게 함으로써 시스템의 활용도를 높입니다.

**→ Time sharing은 멀티유저 환경에서 자원을 공유하는 방식을 강조**

### Multiprocess

여러 개의 프로세스가 동시에 실행되는 시스템을 의미합니다.\
이는 병렬 처리를 통해 작업의 처리 속도를 향상시킬 수 있습니다.\
운영체제는 여러 개의 프로세서를 활용하여 프로세스들을 병렬적으로 실행하고, 작업을 분할하여 각 프로세서에서 동시에 처리할 수 있도록 합니다.\
Multiprocess는 대규모 시스템에서 성능과 처리량을 향상시키는 데 중점을 둡니다.

**→ Multiprocess는 병렬 처리를 강조하여 성능 향상을 목표**

## 운영 체제의 예

![](/img/os-01-10.png)

- 대형 컴퓨터(서버)를 위해 만들어짐
- 유닉스를 어셈블리어로 만들다 보니 코드가 복잡하고 어려움 → 고급언어 C언어 만듬
- C언어로 작성 → 높은 이식성
  <details>
    <summary>자세히 보기</summary>
    1. 기계어 독립성:
     C 언어는 기계어 독립적인 특성을 가지고 있습니다. 즉, C 언어로 작성된 프로그램은 특정한 하드웨어 아키텍처에 종속되지 않고 여러 종류의 시스템에서 실행될 수 있습니다. 이는 C 언어로 작성된 UNIX 운영체제가 다양한 컴퓨터 아키텍처에서 이식 가능한 이유 중 하나입니다. C 언어로 작성된 UNIX 운영체제는 기계어와 밀접한 관련이 있는데, C 언어는 기계어와 밀접하게 상호작용하면서 하드웨어의 특성을 추상화하여 이식성을 높입니다.
  1. 어셈블리어와의 접근성:
     C 언어는 어셈블리어와 밀접한 관련이 있습니다. C 언어로 작성된 코드는 어셈블리어로 직접 변환되어 기계어로 실행됩니다. 이러한 특성은 C 언어로 작성된 운영체제가 어셈블리어와 기계어와의 접근성을 가지고 있어서 다양한 하드웨어 아키텍처에서 쉽게 이식될 수 있도록 도와줍니다. UNIX 운영체제는 C 언어로 작성되었기 때문에, 어셈블리어로 작성된 하드웨어 종속적인 코드의 양을 최소화하고, 이식성을 향상시킬 수 있었습니다.
     기계어는 컴퓨터 아키텍처에 따라 다양한 종류가 존재합니다. 각각의 컴퓨터 아키텍처는 고유한 기계어 명령어 세트를 가지고 있으며, 이러한 명령어 세트는 해당 아키텍처에서 직접 실행될 수 있는 바이너리 형태의 명령어로 구성됩니다.
     따라서, 운영체제가 기계어에 종속되지 않고 이식성을 갖추기 위해서는 여러 종류의 기계어를 지원해야 합니다. UNIX 운영체제가 C 언어로 작성되었기 때문에 이식성이 높다는 이유 중 하나는 C 언어를 기계어로 변환하는 과정에서 해당 컴퓨터 아키텍처에 맞는 기계어로 변환되기 때문입니다.
     즉, C 언어는 기계어와의 인터페이스 역할을 수행하며, 컴파일러를 통해 해당 아키텍처의 기계어로 변환됩니다. 이를 통해 UNIX 운영체제는 다양한 컴퓨터 아키텍처에서 실행될 수 있게 됩니다. 이식성이 높다는 이유는 C 언어를 중간 단계로 사용하여 기계어에 종속되지 않고 여러 아키텍처에서 실행될 수 있게 한다는 점에서 나타납니다.
  </details>
- 커널 → 운영체제에서 메모리에 상주하는 핵심부분, 커널을 최소한으로 했기 때문에 메모리 요구 적음

![](/img/os-01-11.png)

- 개인용 컴퓨터(PC)를 위해 만들어짐
- 소스 코드 공개 X, 상업화(Vendor)
- MS에서 단일 사용자에게는 RAM이 640KB 이상 필요할 일이 없다고 생각하여 640KB까지 지원하는 운영체제인 DOS 개발
- 초창기의 Windows는 불안정했지만 현재는 양호한 편

## 운영체제의 구조

![](/img/os-01-12.png)

[강의](https://core.ewha.ac.kr/publicview/C0101020140307151724641842?vmode=f)
